# 第 6 章　算法篇总结


## mutator 和 GC 的执行关系


![mutator-and-gc.drawio.svg](./images/mutator-and-gc.drawio.svg)

图中并列的箭头表示可能会并行执行的处理。

从图 6.1 中可以看出，转移专用记忆集合维护线程和 mutator 在大多数时间中是并发执行的，但是在存活对象计数（2.7 节）时，转移专用记忆集合维护线程也是暂停的。

还有一点需要注意，那就是转移处理可能发生在并发标记中暂停处理以外的所有时刻。比如在并发标记阶段或者存活对象计数的过程中，都可能执行转移。

## 优点

首先，G1GC 具备软实时性，这是一个很大的优点。对于要求软实时性的应用程序，可以由用户控制 GC 暂停时间。

其次，它能够充分发挥高配置机器的性能，大幅缩减 GC 暂停时间，这一点也值得表扬。虽然考虑到算法，总有一些必须要暂停的阶段，但这些阶段也可以通过尽可能地并行执行，来进一步缩短暂停时间。

再次，它通过将写屏障的处理粒度由对象粒度改为更粗的卡片粒度，降低了写屏障发生的频率。这也是缩短暂停时间的一个手段。


另外，因为有转移，所以区域内不会产生内存碎片。由此可以提高引用的局部性和对象存储空间分配的速度。

与其他具备软实时性的 GC 相比，G1GC 的吞吐量保持在较高水平。近年，很多具备软实时性的 GC[6]、[5]会通过频繁地执行“以对象为单位进行复制”这种更细粒度的暂停处理来缩短 GC 暂停时间，从而达成软实时性。因此，无论如何它们的吞吐量都是下降的。另外，这些 GC 中死亡对象的回收处理可能存在延迟，因此内存的使用效率也不高。

而 G1GC 以区域这种较粗的粒度来频繁地执行用户指定时间内的暂停处理，所以暂停时间会稍微长一些，它的吞吐量也会高一些。此外，通过在转移时选择合适的回收集合，还能够更高效地回收死亡对象。

## 缺点

G1GC 的适用对象被限定为“搭载多核处理器、拥有大容量内存的机器”。在多数环境下，我们并不能发挥出它的性能。适用环境受限可以说是它的一个缺点。

另外在转移时，尽管区域内不会出现碎片化，但是会出现以区域为单位（整个堆）的碎片化。和普通的 GC 复制算法相比，这一点算是缺点。

