# 第 2 章　并发标记

- 并发标记的主要作用是提供转移过程所需要的信息
- 标记位图
- TAMS是`Top At Marking Start`（标记开始时的top）的缩写
- 根扫描
- SATB (Snapshot At The Beginning，初始快照)
- 汤浅的算法
- 写屏障技术
- SATB 专用写屏障
- SATB 本地队列
- 全局的SATB 队列
- nextTAMS
- prevTAMS
- next_marked_bytes
- prev_marked_bytes
- 转移效率=死亡对象的字节数÷转移所需时间
- 

## 并发标记

在简单标记中，所有可从根直接触达的对象都会被添加标记。带标记的是存活对象，不带标记的是死亡对象

需要注意的是，并发标记其实并不是直接在对象上添加标记，而是在`标记位图`上添加标记。标记位图：将用于标记的比特值等信息单独拿出来放到其他地方，用来匹配对应的对象

并发标记过程包括以下 5 个步骤:

- ①初始标记阶段
- ②并发标记阶段
- ③最终标记阶段
- ④存活对象计数
- ⑤收尾工作


## 初始标记阶段

在初始标记阶段，GC 线程首先会创建标记位图next。nextTAMS指的就是标记开始时top所在的位置，所以在这里我们将它和top对齐。在创建位图时，其大小也和top对齐，为“（top-bottom）/8”字节。这些处理都是和 mutator 并发进行的。

对可由根直接引用的对象进行标记的过程叫作根扫描。等所有区域的标记位图都创建完成之后，就可以开始进行根扫描了。

为了防止在根扫描的过程中根被修改，在这个过程中 mutator 是暂停执行的。虽然 G1GC 中采用的写屏障技术可以获知对象的修改，但是大多数根并不是对象，它们的修改并不能被写屏障获知，因此在进行根扫描时必须暂停 mutator 的执行。

根需要频繁修改，所以其中大部分不在写屏障可以获知的范围内。也许G1GC 的设计者认为，与其频繁地通过写屏障去获知修改的方式，还不如直接暂停 mutator 来进行根扫描的方式性能更佳。


## 并发标记阶段

在并发标记阶段，GC 线程继续扫描在初始标记阶段被标记过的对象，完成对大部分存活对象的标记。

### SATB 写屏障

SATB 专用写屏障的优化和汤浅的算法相比，SATB 专用写屏障有以下两点不同之处。①不检查目标对象是否被标记②不对目标对象进行标记但是①和②的处理并不是消失了，而是由 GC 线程在并发标记过程中处理了。这样做就可以减少写屏障的开销，增加并发标记的开销。

这种优化的目的，在于将写屏障的系统负荷转移到并发标记处理中，从而分担 mutator 的负担。因为 mutator 会频繁地执行写屏障，所以减少写屏障的开销也会减轻 mutator 的负担。而且，并发标记处理是由 GC线程和 mutator 并发执行的，所以多个 mutator 就能平摊这些负担，进而减轻单个 mutator 的负担。如果把这些优化放到不支持并发标记的 GC 中，该 GC 的负荷反而会增加。这种针对写屏障的优化，可以说是专为采用了并发标记的 G1GC 设计的。

## 最终标记阶段

最终标记阶段最终标记阶段的处理是暂停处理，需要暂停 mutator 的运行。因为未装满的 SATB 本地队列不会被添加到 SATB 队列集合中，所以在并发标记阶段结束后，各个线程的 SATB 本地队列中可能仍然存在待扫描的对象。而最终标记阶段就会扫描这些“残留的 SATB 本地队列”。

本步骤结束后，所有的存活对象都已被标记。因此，此时所有不带标记的对象都可以判定为死亡对象。

因为 SATB 本地队列中的数据会被 mutator 操作，所以本步骤不能和mutator 并发执行。

## 存活对象计数

这个步骤会扫描各个区域的标记位图next，统计区域内存活对象的字节数，然后将其存入区域内的next_marked_bytes中。

计数处理和 mutator 是并发执行的。但是，计数过程中操作的对象也可能会被转移的记忆集合（remembered set）线程使用，因此需要先停掉记忆集合线程。

## 收尾工作

收尾工作所操作的数据中有些是和 mutator 共享的，因此需要暂停mutator 的运行。


## 总结

并发标记结束后，转移处理可以得到以下信息（参考图 2.10）。①并发标记完成时存活对象和死亡对象的区分（标记位图prev）②存活对象的字节数（prev_marked_bytes）这些信息在并发标记阶段不会被改变，因此，即使在并发标记阶段就开始转移处理也不会有问题。另外，虽然新的对象是在并发标记结束后被创建的，但由于它是分配在prevTAMS和top之间的，所以会被当成存活对象处理。