# 第 1 章　G1GC 是什么

- 实时性
- 可预测性
- 增量 GC
- 吞吐量
- 堆结构

## 实时性

G1GC 最大的特征是非常重视实时。

实时性处理实时性的要求是，它必须能在最后期限（deadline）之前完成。最后期限可以自由指定。如果指定的期限较短，那么程序就要保证在短时间内完成处理；相反，如果指定的期限较长，那么程序只要能保证在这个较长的时间内完成处理就可以了。另外，即使同为实时程序，如果处理内容不同，最后期限的重要性也会很不一样。有些处理只要超出最后期限一次，就会带来致命的问题，而有些处理稍微打破几次最后期限也不会有太大的问题。这两种处理分别称为“硬实时性（hard real-time）处理”和“软实时性（soft real-time）处理”。

## 可预测性

这里所说的可预测性，指的是“可以预测处理大约会耗费多长时间”。即使处理速度再快，如果无法在执行前预测出需要的时间，处理也是没有使用价值的——因为该处理存在随时超出最后期限的可能。如果能够预测出大致的处理时间，就可以据此来评估是否会超出最后期限。如果有超出期限的可能，就可以事先采取应对措施，例如对处理内容进行分解。因此，在保证实时性方面，可预测性是一个重要的因素。

## G1GC 中的实时性

G1GC 具有软实时性。为了实现软实时性，它具备以下两个功能。①设置期望暂停时间（最后期限）②可预测性①是支持用户自定义 mutator 暂停时间的功能。G1GC 具有软实时性，因此会尽力保证处理不超过该暂停时间。②是用来预测下次 GC 会导致 mutator 暂停多长时间的功能。根据预测出来的结果，G1GC 会通过延迟执行 GC、拆分 GC 目标对象等手段来遵守①中设置的期望暂停时间。通过这种方式，能够尽量减少超出用户期望暂停时间的频率，从而实现软实时性。

## 增量 GC

增量 GC ：通过慢慢地进行 GC 来缩短 mutator 最大暂停时间的一种手段

这类应用程序当前主要是采用增量 GC 或者并发 GC 来缩短最大暂停时间的。但是，缩短最大暂停时间很容易导致吞吐量下降。还有，因为无法预测暂停时间，GC 可能会有 mutator 长时间停止的风险。

吞吐量：单位时间内回收垃圾的量。如果 GC 的吞吐量下降，总的暂停时间就会变长。

于是 G1GC 诞生了，其目的就是高效地实现软实时性。Java 先前的 GC算法都在一味地尝试缩短最大暂停时间，而 G1GC 则是让用户去设置期望暂停时间。用户按照自己的需求设置合适的 GC 暂停时间，在确保吞吐量比以往的 GC 更好的前提下，实现了软实时性。另外，追求软实时性的服务端应用程序，大都运行在拥有巨大的堆和多处理器的服务器设备之上。因此，内部的 GC 算法必须能够在短时间内以高吞吐量来处理巨大的堆，而且还要高效地发挥多处理器的优势。G1GC 的设计就很符合这些要求，它能够最大程度地利用服务器上多处理器的优势，而且在处理巨大的堆时，也不会降低 GC 的性能。

## G1GC 简化执行过程

- ①并发标记（concurrent marking）
- ②转移（evacuation）


## 并发标记和转移

，G1GC 的主要功能是并发标记和转移。其中并发标记由并发标记线程来执行。并发标记的作用是在尽量不暂停 mutator 的情况下标记出存活对象。而且，还需要在并发标记结束之后记录下每个区域内存活对象的数量。这个信息在转移时会用到。转移的作用是将待回收区域内的存活对象复制到其他的空闲区域，然后将待回收区域重置为空闲状态。这很像复制 GC 算法，只不过是以区域为单位进行的。需要注意的是，并发标记和转移在处理上是相互独立的。并发标记的结果信息对于转移来说并不是必须的。因此，转移处理可能发生在并发标记开始之前，也可能发生在并发标记的过程中。