# 第 20 章　写屏障的性能开销

- G1SATBCardTableLoggingModRefBS
- CardTableModRefBSForCTRS
- JIT 编译器的写屏障
- JIT 编译器有 C1、C2 和 Shark 三种

## 写屏障的性能开销增加

在运行时切换 GC 算法，最有可能出现性能下降的地方是写屏障。写屏障是一项会被频繁执行的处理，它很容易成为性能瓶颈。在切换 GC 算法时，如果这些 GC 算法需要不同的写屏障，那么写屏障也会发生切换。也就是说，代码清单 20.1 中根据条件分支切换 GC 算法的做法需要发生在写屏障内。因此，这会增加写屏障的性能开销，影响 mutator 的速度。

在 G1GC 加入前，写屏障只有一种

经过一番调查后我惊讶地发现，在 G1GC 加入前（即 OpenJDK 7 之前）是没有运行时写屏障切换的。那时，HotSpotVM 中只实现了“记录卡表被改写”这么一个简单功能（只有CardTableModRefBSForCTRS）。不过仔细一想就会发现，其实分代GC 和增量 GC 只要有这个功能就可以了。之后加入新的写屏障不过是因为 G1GC 的写屏障太过特殊了。

由于自 OpenJDK 7 引入 G1GC 后，写屏障切换也随之发生，因此解释器给对象赋值的操作的性能稍微有所下降。

