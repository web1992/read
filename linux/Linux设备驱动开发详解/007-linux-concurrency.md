# 第7章 Linux设备驱动中的并发控制

- 编译乱序、执行乱序 内存屏障
- 中断屏蔽、原子操作、自旋锁、信号量和互斥体等并发控制机制
- 竞态（Race Conditions）
- 对称多处理器（SMP）的多个CPU
- SMP体系结构
- 中断（硬中断、软中断、Tasklet、底半部）与进程之间
- 临界区（CriticalSections）
- 中断屏蔽、原子操作、自旋锁、信号量、互斥体等是Linux设备驱动中可采用的互斥途径
- 编译乱序 执行乱序。
- 编译器可以对访存的指令进行乱序，减少逻辑上 不必要的访存，以及尽量提高Cache命中率和CPU的 Load/Store单元的工作效率。
- barrier
- #define barrier() __asm__ __volatile__("": : :"memory") 编译屏障
- 执行乱序
- 编译乱序
- 中断屏蔽
- local_irq_disable()  屏蔽中断
- local_irq_enable()  开中断
- 其底层的实现原理是让CPU本身不响应中断
- local_irq_save
- local_irq_restore
- 自旋锁（Spin Lock）
- 在ARM体系结构下，自旋锁的实现借用了ldrex指令、strex指令、ARM处理器内存屏障指令dmb和dsb、wfe指令和sev指令，
- spinlock_t lock;
- spin_lock_init(lock)
- spin_lock(lock)
- spin_trylock(lock)
- spin_unlock(lock
- 自旋锁机制+开关中断
- RCU（Read-Copy-Update，读-复制-更新）
- 信号量（Semaphore）
- struct mutex 互斥体
- mutex_lock
- mutex_unlock
- mutex_lock_interruptible
- Completion 完成量

## 单CPU内进程与抢占它的进程

Linux 2.6以后的内核支持内核抢占调度，一个进
程在内核执行的时候可能耗完了自己的时间片
（timeslice），也可能被另一个高优先级进程打断，
进程与抢占它的进程访问共享资源的情况类似于SMP的
多个CPU。


## volatile

关于解决编译乱序的问题，C语言volatile关键字
的作用较弱，它更多的只是避免内存访问行为的合
并，对C编译器而言，volatile是暗示除了当前的执行
线索以外，其他的执行线索也可能改变某内存，所以
它的含义是“易变的”。


换句话说，就是如果线程A读
取var这个内存中的变量两次而没有修改var，编译器
可能觉得读一次就行了，第2次直接取第1次的结果。
但是如果加了volatile关键字来形容var，则就是告诉
编译器线程B、线程C或者其他执行实体可能把var改掉
了，因此编译器就不会再把线程A代码的第2次内存读
取优化掉了。另外，volatile也不具备保护临界资源
的作用。总之，Linux内核明显不太喜欢volatile，这
可参考内核源代码下的文档Documentation/volatileconsidered-harmful.txt。

## 执行乱序

编译乱序是编译器的行为，而执行乱序则是处理
器运行时的行为。执行乱序是指即便编译的二进制指
令的顺序按照“p->a=1；p->b=2；p->c=3；gp=p；”
排放，在处理器上执行时，后发射的指令还是可能先
执行完，这是处理器的“乱序执行（Out-of-Order
Execution）”策略。高级的CPU可以根据自己缓存的
组织特性，将访存指令重新排序执行。连续地址的访
问可能会先执行，因为这样缓存命中率高。有的还允
许访存的非阻塞，即如果前面一条访存指令因为缓存
不命中，造成长延时的存储访问时，后面的访存指令
可以先执行，以便从缓存中取数。因此，即使是从汇
编上看顺序正确的指令，其执行的顺序也是不可预知
的。


## 内存屏障

DMB（数据内存屏障）：在DMB之后的显式内存访
问执行前，保证所有在DMB指令之前的内存访问完成；

DSB（数据同步屏障）：等待所有在DSB指令之前
的指令完成（位于此指令前的所有显式内存访问均完
成，位于此指令前的所有缓存、跳转预测和TLB维护操
作全部完成）；

ISB（指令同步屏障）：Flush流水线，使得所有
ISB之后执行的指令都是从缓存或内存中获得的。

Linux内核的自旋锁、互斥体等互斥逻辑，需要用
到上述指令：在请求获得锁时，调用屏障指令；在解
锁时，也需要调用屏障指令。

在Linux内核中，定义了读写屏障mb（）、读屏障
rmb（）、写屏障wmb（）、以及作用于寄存器读写的
__iormb（）、__iowmb（）这样的屏障API。读写寄存
器的readl_relaxed（）和readl（）、
writel_relaxed（）和writel（）API的区别就体现在
有无屏障方面。

## 中断屏蔽

在单CPU范围内避免竞态的一种简单而有效的方法
是在进入临界区之前屏蔽系统的中断，但是在驱动编
程中不值得推荐，驱动通常需要考虑跨平台特点而不
假定自己在单核上运行。CPU一般都具备屏蔽中断和打
开中断的功能，这项功能可以保证正在执行的内核执
行路径不被中断处理程序所抢占，防止某些竞态条件
的发生。具体而言，中断屏蔽将使得中断与进程之间
的并发不再发生，而且，由于Linux内核的进程调度等
操作都依赖中断来实现，内核抢占进程之间的并发也
得以避免了。

## local_irq_disable

local_irq_disable（）和local_irq_enable（）
都只能禁止和使能本CPU内的中断，因此，并不能解决
SMP多CPU引发的竞态。因此，单独使用中断屏蔽通常
不是一种值得推荐的避免竞态的方法（换句话说，驱
动中使用local_irq_disable/enable（）通常意味着
一个bug），它适合与下文将要介绍的自旋锁联合使用。

## 原子操作

原子操作可以保证对一个整型数据的修改是排他
性的。Linux内核提供了一系列函数来实现内核中的原
子操作，这些函数又分为两类，分别针对位和整型变
量进行原子操作。位和整型变量的原子操作都依赖于
底层CPU的原子操作，因此所有这些函数都与CPU架构
密切相关。对于ARM处理器而言，底层使用LDREX和
STREX指令，比如atomic_inc（）底层的实现会调用到
atomic_add（）

```c
static inline void atomic_add(int i, atomic_t *v)
{
unsigned long tmp;
int result;
prefetchw(&v->counter);
__asm__ __volatile__("@ atomic_add\n"
"1: ldrex %0, [%3]\n"
" add %0, %0, %4\n"
" strex %1, %0, [%3]\n"
" teq %1, #0\n"
" bne 1b"
: "=&r" (result), "=&r" (tmp), "+Qo" (v->counter)
: "r" (&v->counter), "Ir" (i)
: "cc");
}
```

ldrex指令跟strex配对使用，可以让总线监控
ldrex到strex之间有无其他的实体存取该地址，如果
有并发的访问，执行strex指令时，第一个寄存器的值
被设置为1（Non-Exclusive Access）并且存储的行为
也不成功；如果没有并发的存取，strex在第一个寄存
器里设置0（Exclusive Access）并且存储的行为也是
成功的。


本例中，如果两个并发实体同时调用
ldrex+strex，如图7.6所示，在T3时间点上，CPU0的
strex会执行失败，在T4时间点上CPU1的strex会执行
成功。所以CPU0和CPU1之间只有CPU1执行成功了，执
行strex失败的CPU0的“teq%1，#0”判断语句不会成
立，于是失败的CPU0通过“bne 1b”再次进入ldrex。
ldrex和strex的这一过程不仅适用于多核之间的并
发，也适用于同一个核内部并发的情况

## spin_lock_irqsave

spin_lock_irq（）、spin_lock_irqsave（）、
spin_lock_bh（）类似函数会为自旋锁的使用系好
“安全带”以避免突如其来的中断驶入对系统造成的
伤害

## 自旋锁

驱动工程师应谨慎使用自旋锁，而且在使用中还
要特别注意如下几个问题。
1）自旋锁实际上是忙等锁，当锁不可用时，CPU
一直循环执行“测试并设置”该锁直到可用而取得该
锁，CPU在等待自旋锁时不做任何有用的工作，仅仅是
等待。因此，只有在占用锁的时间极短的情况下，使
用自旋锁才是合理的。当临界区很大，或有共享设备
的时候，需要较长时间占用锁，使用自旋锁会降低系
统的性能。
2）自旋锁可能导致系统死锁。引发这个问题最常
见的情况是递归使用一个自旋锁，即如果一个已经拥
有某个自旋锁的CPU想第二次获得这个自旋锁，则该
CPU将死锁。
图7.8 自旋锁的使用实例
3）在自旋锁锁定期间不能调用可能引起进程调度
的函数。如果进程获得自旋锁之后再阻塞，如调用
copy_from_user（）、copy_to_user（）、
kmalloc（）和msleep（）等函数，则可能导致内核的
崩溃。
4）在单核情况下编程的时候，也应该认为自己的
CPU是多核的，驱动特别强调跨平台的概念。比如，在
单CPU的情况下，若中断和进程可能访问同一临界区，
进程里调用spin_lock_irqsave（）是安全的，在中断
里其实不调用spin_lock（）也没有问题，因为
spin_lock_irqsave（）可以保证这个CPU的中断服务
程序不可能执行。但是，若CPU变成多核，
spin_lock_irqsave（）不能屏蔽另外一个核的中断，
所以另外一个核就可能造成并发问题。因此，无论如
何，我们在中断服务程序里也应该调用
spin_lock（）。

## 自旋锁和互斥体

自旋锁和互斥体都是解决互斥问题的基本手段，
面对特定的情况，应该如何取舍这两种手段呢？选择
的依据是临界区的性质和系统的特点。
从严格意义上说，互斥体和自旋锁属于不同层次
的互斥手段，前者的实现依赖于后者。在互斥体本身
的实现上，为了保证互斥体结构存取的原子性，需要
自旋锁来互斥。所以自旋锁属于更底层的手段。
互斥体是进程级的，用于多个进程之间对资源的
互斥，虽然也是在内核中，但是该内核执行路径是以
进程的身份，代表进程来争夺资源的。如果竞争失
败，会发生进程上下文切换，当前进程进入睡眠状
态，CPU将运行其他进程。鉴于进程上下文切换的开销
也很大，因此，只有当进程占用资源时间较长时，用
互斥体才是较好的选择。
当所要保护的临界区访问时间比较短时，用自旋
锁是非常方便的，因为它可节省上下文切换的时间。
但是CPU得不到自旋锁会在那里空转直到其他执行单元
解锁为止，所以要求锁不能在临界区里长时间停留，
否则会降低系统的效率。
由此，可以总结出自旋锁和互斥体选用的3项原
则。
1）当锁不能被获取到时，使用互斥体的开销是进
程上下文切换时间，使用自旋锁的开销是等待获取自
旋锁（由临界区执行时间决定）。若临界区比较小，
宜使用自旋锁，若临界区很大，应使用互斥体。
2）互斥体所保护的临界区可包含可能引起阻塞的
代码，而自旋锁则绝对要避免用来保护包含这样代码
的临界区。因为阻塞意味着要进行进程的切换，如果
进程被切换出去后，另一个进程企图获取本自旋锁，
死锁就会发生。
3）互斥体存在于进程上下文，因此，如果被保护
的共享资源需要在中断或软中断情况下使用，则在互
斥体和自旋锁之间只能选择自旋锁。当然，如果一定
要使用互斥体，则只能通过mutex_trylock（）方式进
行，不能获取就立即返回以避免阻塞。


## completion

```c
struct completion my_completion;
init_completion(&my_completion);
reinit_completion(&my_completion);
wait_for_completion(&my_completion);
complete(&my_completion)
complete_all(&my_completion)
```


## 总结

并发和竞态广泛存在，中断屏蔽、原子操作、自
旋锁和互斥体都是解决并发问题的机制。中断屏蔽很
少单独被使用，原子操作只能针对整数进行，因此自
旋锁和互斥体应用最为广泛。
自旋锁会导致死循环，锁定期间不允许阻塞，因
此要求锁定的临界区小。互斥体允许临界区阻塞，可
以适用于临界区大的情况