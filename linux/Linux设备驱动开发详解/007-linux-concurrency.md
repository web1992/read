# 第7章 Linux设备驱动中的并发控制

- 编译乱序、执行乱序 内存屏障
- 中断屏蔽、原子操作、自旋锁、信号量和互斥体等并发控制机制
- 竞态（Race Conditions）
- 对称多处理器（SMP）的多个CPU
- SMP体系结构
- 中断（硬中断、软中断、Tasklet、底半部）与进程之间
- 临界区（CriticalSections）
- 中断屏蔽、原子操作、自旋锁、信号量、互斥体等是Linux设备驱动中可采用的互斥途径
- 编译乱序 执行乱序。
- 编译器可以对访存的指令进行乱序，减少逻辑上 不必要的访存，以及尽量提高Cache命中率和CPU的 Load/Store单元的工作效率。
- barrier
- #define barrier() __asm__ __volatile__("": : :"memory") 编译屏障
- 执行乱序
- 编译乱序
- 中断屏蔽
- local_irq_disable()  屏蔽中断
- local_irq_enable()  开中断
- 其底层的实现原理是让CPU本身不响应中断
- local_irq_save
- local_irq_restore
- 自旋锁（Spin Lock）
- 在ARM体系结构下，自旋锁的实现借用了ldrex指令、strex指令、ARM处理器内存屏障指令dmb和dsb、wfe指令和sev指令，
- spinlock_t lock;
- spin_lock_init(lock)
- spin_lock(lock)
- spin_trylock(lock)
- spin_unlock(lock
- 自旋锁机制+开关中断

## 单CPU内进程与抢占它的进程

Linux 2.6以后的内核支持内核抢占调度，一个进
程在内核执行的时候可能耗完了自己的时间片
（timeslice），也可能被另一个高优先级进程打断，
进程与抢占它的进程访问共享资源的情况类似于SMP的
多个CPU。


## volatile

关于解决编译乱序的问题，C语言volatile关键字
的作用较弱，它更多的只是避免内存访问行为的合
并，对C编译器而言，volatile是暗示除了当前的执行
线索以外，其他的执行线索也可能改变某内存，所以
它的含义是“易变的”。


换句话说，就是如果线程A读
取var这个内存中的变量两次而没有修改var，编译器
可能觉得读一次就行了，第2次直接取第1次的结果。
但是如果加了volatile关键字来形容var，则就是告诉
编译器线程B、线程C或者其他执行实体可能把var改掉
了，因此编译器就不会再把线程A代码的第2次内存读
取优化掉了。另外，volatile也不具备保护临界资源
的作用。总之，Linux内核明显不太喜欢volatile，这
可参考内核源代码下的文档Documentation/volatileconsidered-harmful.txt。

## 执行乱序

编译乱序是编译器的行为，而执行乱序则是处理
器运行时的行为。执行乱序是指即便编译的二进制指
令的顺序按照“p->a=1；p->b=2；p->c=3；gp=p；”
排放，在处理器上执行时，后发射的指令还是可能先
执行完，这是处理器的“乱序执行（Out-of-Order
Execution）”策略。高级的CPU可以根据自己缓存的
组织特性，将访存指令重新排序执行。连续地址的访
问可能会先执行，因为这样缓存命中率高。有的还允
许访存的非阻塞，即如果前面一条访存指令因为缓存
不命中，造成长延时的存储访问时，后面的访存指令
可以先执行，以便从缓存中取数。因此，即使是从汇
编上看顺序正确的指令，其执行的顺序也是不可预知
的。


## 内存屏障

DMB（数据内存屏障）：在DMB之后的显式内存访
问执行前，保证所有在DMB指令之前的内存访问完成；

DSB（数据同步屏障）：等待所有在DSB指令之前
的指令完成（位于此指令前的所有显式内存访问均完
成，位于此指令前的所有缓存、跳转预测和TLB维护操
作全部完成）；

ISB（指令同步屏障）：Flush流水线，使得所有
ISB之后执行的指令都是从缓存或内存中获得的。

Linux内核的自旋锁、互斥体等互斥逻辑，需要用
到上述指令：在请求获得锁时，调用屏障指令；在解
锁时，也需要调用屏障指令。

在Linux内核中，定义了读写屏障mb（）、读屏障
rmb（）、写屏障wmb（）、以及作用于寄存器读写的
__iormb（）、__iowmb（）这样的屏障API。读写寄存
器的readl_relaxed（）和readl（）、
writel_relaxed（）和writel（）API的区别就体现在
有无屏障方面。

## 中断屏蔽

在单CPU范围内避免竞态的一种简单而有效的方法
是在进入临界区之前屏蔽系统的中断，但是在驱动编
程中不值得推荐，驱动通常需要考虑跨平台特点而不
假定自己在单核上运行。CPU一般都具备屏蔽中断和打
开中断的功能，这项功能可以保证正在执行的内核执
行路径不被中断处理程序所抢占，防止某些竞态条件
的发生。具体而言，中断屏蔽将使得中断与进程之间
的并发不再发生，而且，由于Linux内核的进程调度等
操作都依赖中断来实现，内核抢占进程之间的并发也
得以避免了。

## local_irq_disable

local_irq_disable（）和local_irq_enable（）
都只能禁止和使能本CPU内的中断，因此，并不能解决
SMP多CPU引发的竞态。因此，单独使用中断屏蔽通常
不是一种值得推荐的避免竞态的方法（换句话说，驱
动中使用local_irq_disable/enable（）通常意味着
一个bug），它适合与下文将要介绍的自旋锁联合使用。

## 原子操作

原子操作可以保证对一个整型数据的修改是排他
性的。Linux内核提供了一系列函数来实现内核中的原
子操作，这些函数又分为两类，分别针对位和整型变
量进行原子操作。位和整型变量的原子操作都依赖于
底层CPU的原子操作，因此所有这些函数都与CPU架构
密切相关。对于ARM处理器而言，底层使用LDREX和
STREX指令，比如atomic_inc（）底层的实现会调用到
atomic_add（）

```c
static inline void atomic_add(int i, atomic_t *v)
{
unsigned long tmp;
int result;
prefetchw(&v->counter);
__asm__ __volatile__("@ atomic_add\n"
"1: ldrex %0, [%3]\n"
" add %0, %0, %4\n"
" strex %1, %0, [%3]\n"
" teq %1, #0\n"
" bne 1b"
: "=&r" (result), "=&r" (tmp), "+Qo" (v->counter)
: "r" (&v->counter), "Ir" (i)
: "cc");
}
```

ldrex指令跟strex配对使用，可以让总线监控
ldrex到strex之间有无其他的实体存取该地址，如果
有并发的访问，执行strex指令时，第一个寄存器的值
被设置为1（Non-Exclusive Access）并且存储的行为
也不成功；如果没有并发的存取，strex在第一个寄存
器里设置0（Exclusive Access）并且存储的行为也是
成功的。


本例中，如果两个并发实体同时调用
ldrex+strex，如图7.6所示，在T3时间点上，CPU0的
strex会执行失败，在T4时间点上CPU1的strex会执行
成功。所以CPU0和CPU1之间只有CPU1执行成功了，执
行strex失败的CPU0的“teq%1，#0”判断语句不会成
立，于是失败的CPU0通过“bne 1b”再次进入ldrex。
ldrex和strex的这一过程不仅适用于多核之间的并
发，也适用于同一个核内部并发的情况

## spin_lock_irqsave

spin_lock_irq（）、spin_lock_irqsave（）、
spin_lock_bh（）类似函数会为自旋锁的使用系好
“安全带”以避免突如其来的中断驶入对系统造成的
伤害

## 自旋锁

驱动工程师应谨慎使用自旋锁，而且在使用中还
要特别注意如下几个问题。
1）自旋锁实际上是忙等锁，当锁不可用时，CPU
一直循环执行“测试并设置”该锁直到可用而取得该
锁，CPU在等待自旋锁时不做任何有用的工作，仅仅是
等待。因此，只有在占用锁的时间极短的情况下，使
用自旋锁才是合理的。当临界区很大，或有共享设备
的时候，需要较长时间占用锁，使用自旋锁会降低系
统的性能。
2）自旋锁可能导致系统死锁。引发这个问题最常
见的情况是递归使用一个自旋锁，即如果一个已经拥
有某个自旋锁的CPU想第二次获得这个自旋锁，则该
CPU将死锁。
图7.8 自旋锁的使用实例
3）在自旋锁锁定期间不能调用可能引起进程调度
的函数。如果进程获得自旋锁之后再阻塞，如调用
copy_from_user（）、copy_to_user（）、
kmalloc（）和msleep（）等函数，则可能导致内核的
崩溃。
4）在单核情况下编程的时候，也应该认为自己的
CPU是多核的，驱动特别强调跨平台的概念。比如，在
单CPU的情况下，若中断和进程可能访问同一临界区，
进程里调用spin_lock_irqsave（）是安全的，在中断
里其实不调用spin_lock（）也没有问题，因为
spin_lock_irqsave（）可以保证这个CPU的中断服务
程序不可能执行。但是，若CPU变成多核，
spin_lock_irqsave（）不能屏蔽另外一个核的中断，
所以另外一个核就可能造成并发问题。因此，无论如
何，我们在中断服务程序里也应该调用
spin_lock（）。